# This file is a template, and might need editing before it works on your project.
# To contribute improvements to CI/CD templates, please follow the Development guide at:
# https://docs.gitlab.com/ee/development/cicd/templates.html
# This specific template is located at:
# https://gitlab.com/gitlab-org/gitlab/-/blob/master/lib/gitlab/ci/templates/Gradle.gitlab-ci.yml

# This is the Gradle build system for JVM applications
# https://gradle.org/
# https://github.com/gradle/gradle

# Disable the Gradle daemon for Continuous Integration servers as correctness
# is usually a priority over speed in CI environments. Using a fresh
# runtime for each build is more reliable since the runtime is completely
# isolated from any previous builds.
variables:
  GRADLE_OPTS: "-Dorg.gradle.daemon=false"
  CI_REGISTRY_IMAGE: $CI_REGISTRY_IMAGE
  REPOSITORY_USERNAME: ${PORTAL_TOKEN_NAME}
  REPOSITORY_PASSWORD: ${GROUP_CP_TOKEN}

  APP_NAME: $PROJECT_NAME-$PROJECT_SUBNAME-api
  APP_VERSION: "1.3"
  IMAGE_TAGS: $CI_COMMIT_SHA

  SERVICE_PORT: "8081"
  SERVICE_TARGET_PORT: "8081"
  SERVICE_NODEPORT: "32707"

  DATABASE_URL: "cp-mariadb.mariadb.svc.cluster.local:3306"
  DATABASE_USER_ID: cp-admin
  DATABASE_USER_PASSWORD: Paasta!2022


  ENV_SCOPE: dev_aws

  CHART_NAME: cp-terraman-app

build:
  stage: build
  image:
    name: docker.io/gradle:6.5.1-jdk8 # kaniko image 사용
    entrypoint: [""]
  script:
    - export
    - export GRADLE_USER_HOME=`pwd`/.gradle
    - |
      if [[ ! -e gradle/wrapper/gradle-wrapper.jar ]]
      then
        gradle wrapper
      fi
    - chmod +x gradlew
    - ./gradlew build -x test
  cache:
    key: "$CI_COMMIT_REF_NAME"
    paths:
      - build
      - .gradlew

#test:
#  stage: test
#  script:
#    - export
#    - export GRADLE_USER_HOME=`pwd`/.gradle
#    - |
#      if [[ ! -e gradle/wrapper/gradle-wrapper.jar ]]
#      then
#        gradle wrapper
#      fi
#    - chmod +x gradlew
#    - ./gradlew check
#  cache:
#    key: "$CI_COMMIT_REF_NAME"
#    policy: pull
#    paths:
#      - build
#      - .gradle
#  tags:
#    - deploy

docker build:
  stage: docker
  image:
    name: gcr.io/kaniko-project/executor:debug # kaniko image 사용
    entrypoint: [""]
  script:
    - export
    - pwd
    - mkdir -p /kaniko/.docker
    - echo "{\"auths\":{\"${CI_REGISTRY}\":{\"auth\":\"$(printf "%s:%s" "${CI_REGISTRY_USER}" "${CI_REGISTRY_PASSWORD}" | base64 | tr -d '\n')\"}}}" > /kaniko/.docker/config.json
    #- cat /kaniko/.docker/config.json config.json 확인
    - | # ssl cert key 입력
      echo "${GITLAB_CERT_KEY}" >> /kaniko/ssl/certs/additional-ca-cert-bundle.crt
    - >- # build image
      /kaniko/executor
      --context "${CI_PROJECT_DIR}"
      --dockerfile "${CI_PROJECT_DIR}/Dockerfile"
      --destination "${CI_REGISTRY_IMAGE}:${IMAGE_TAGS}"
  cache:
    key: "$CI_COMMIT_REF_NAME"
    paths:
      - build

deploy:
  stage: deploy
  image:
    name: bitnami/kubectl:latest
    entrypoint: [""]
  script:
    - sed -i "s/{IMAGE_TAGS}/$IMAGE_TAGS/g" yaml/Deployment.yaml
    - sed -i "s/{K8S_MASTER_NODE_IP}/$K8S_MASTER_NODE_IP/g" yaml/Deployment.yaml
    - sed -i "s/{K8S_API_SERVER_PORT}/$K8S_API_SERVER_PORT/g" yaml/Deployment.yaml
    - sed -i "s/{IMAGE_PULL_SECRET}/$IMAGE_PULL_SECRET/g" yaml/Deployment.yaml
    - cat yaml/Deployment.yaml
    - kubectl version
    - kubectl create secret docker-registry "$IMAGE_PULL_SECRET" --docker-server="$CI_REGISTRY" --docker-username="$REPOSITORY_USERNAME" --docker-password="$REPOSITORY_PASSWORD" --docker-email="$GITLAB_USER_EMAIL" --namespace="cp-terraman" -o yaml --dry-run=client | kubectl apply -f -; # gitlab registry 사용을 위한 secret 생성
    - kubectl apply -f yaml/Deployment.yaml
  environment:
    name: $ENV_SCOPE

   

#app deploy:
#  stage: deploy
#  image:
#    name: alpine/k8s:1.19.15
#    entrypoint: [""]
#  script:
#    - ls -al $APP_CHART_PATH
#    - export
#    # Common
#    - sed -i "s/\${DEPLOY_NAME}/$APP_NAME/g" $APP_CHART_PATH/values.yaml
#    - sed -i "s/\${NAMESPACE}/$NAMESPACE/g" $APP_CHART_PATH/values.yaml
#    - sed -i "s~\${REPOSITORY_URL}~$CI_REGISTRY~g" $APP_CHART_PATH/values.yaml
#    - sed -i "s~\${REPOSITORY_PROJECT_NAME}~$CI_PROJECT_NAMESPACE~g" $APP_CHART_PATH/values.yaml
#    - sed -i "s/\${IMAGE_NAME}/$CI_PROJECT_TITLE/g" $APP_CHART_PATH/values.yaml
#    - sed -i "s/\${IMAGE_TAGS}/$IMAGE_TAGS/g" $APP_CHART_PATH/values.yaml
#    - sed -i "s/\${IMAGE_PULL_POLICY}/$IMAGE_PULL_POLICY/g" $APP_CHART_PATH/values.yaml
#    - sed -i "s/\${IMAGE_PULL_SECRET}/$IMAGE_PULL_SECRET/g" $APP_CHART_PATH/values.yaml
#    - sed -i "s/\${SERVICE_TYPE}/$SERVICE_TYPE/g" $APP_CHART_PATH/values.yaml
#    - sed -i "s/\${SERVICE_PROTOCOL}/$SERVICE_PROTOCOL/g" $APP_CHART_PATH/values.yaml
#    - sed -i "s/\${SERVICE_PORT}/$SERVICE_PORT/g" $APP_CHART_PATH/values.yaml
#    - sed -i "s/\${SERVICE_TARGET_PORT}/$SERVICE_TARGET_PORT/g" $APP_CHART_PATH/values.yaml
#    - sed -i "s/\${SERVICE_NODEPORT}/$SERVICE_NODEPORT/g" $APP_CHART_PATH/values.yaml
#    - sed -i "s/\${CP_PORTAL_CONFIGMAP_NAME}/$CP_PORTAL_CONFIGMAP_NAME/g" $APP_CHART_PATH/values.yaml
#
#    # for check
#    - cat $APP_CHART_PATH/values.yaml
#
#    - helm package $APP_CHART_PATH
#    #- mv $APP_NAME-$APP_VERSION.tgz $APP_CHART_PATH/$APP_NAME.tgz
#    - helm upgrade --install "$APP_NAME" $CHART_NAME-$APP_VERSION.tgz -f $APP_CHART_PATH/values.yaml -n "$NAMESPACE"
#  environment:
#    name: $ENV_SCOPE

stages:
  - build
  - test
  - docker
  - deploy
